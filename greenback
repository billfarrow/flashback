#!/usr/bin/python -B

import os
import datetime
import subprocess
import shlex
import glob
import operator
import sys
from optparse import OptionParser
import time
import shutil
from configobj import ConfigObj         # apt-get install python-configobj
import imp
import errno


class DefaultsClass:
    def __init__ (self, *argv, **argd):
        self.__dict__.update (argd)

def enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type('Enum', (), enums)


# globals
programName = 'greenback'
topdir = '/backup'
libdir = '/var/lib/'+programName
customize = ('src', 'cycleMin', 'disabled', 'label', 'keepCount')
maxAge = 10000000
sleepMin = 10
# defaults (globals)
class defaults (DefaultsClass):
    lastBackup = '2000-01-01 00:00:00'
    cycleMin = 24*60
    keepCount = 9
    label = 'daily'
# plumbing (globals)
options = ()
g_logFD = None
status = enum('UNKNOWN', 'NOT_READY', 'READY', 'SUCCEEDED', 'FAILED', 'DISABLED')

#-----------------------------------------------------------

def log_init():
    # we're writing these globals
    global g_logFD
    # log file
    #  logdir = os.environ['HOME']+"/var/log"
    #  if not os.path.exists(logdir):
    #     os.makedirs(logdir)
    #  logfile = logdir+"/garage.log"
    #  logfile = programName+'.log'
    logfile = '/dev/stdout'
    g_logFD = open(logfile,'a')

#-----------------------------------------------------------

def log_debug(string):
    if options.debug: log_info(string)

#-----------------------------------------------------------

def log_info(string):
    global g_logFD
    timeStamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    g_logFD.write(timeStamp+" "+string+"\n")
    g_logFD.flush()
    ##os.fsync(g_logFD)

#-----------------------------------------------------------

def shell_capture(cmdargs):
    global g_logFD
    log_debug('shell_capture command >> '+(' '.join(cmdargs)))
    p = subprocess.Popen(cmdargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    rc = p.returncode
    log_debug("shell_capture done, rc="+('%d'%rc))
    return rc, stdout, stderr

#-----------------------------------------------------------

def shell_do(cmdargs):
    global g_logFD
    log_debug('shell_do command >> '+(' '.join(cmdargs)))
    rc = subprocess.call(cmdargs)
    #rc = subprocess.call(cmdargs, stdout=g_logFD, stderr=g_logFD)
    log_debug("shell_do rc = "+("%d"%rc))
    return rc

#-----------------------------------------------------------

def sec2dhms(s):
    days = s // 86400  ; s = s - (days * 86400)
    hours = s // 3600  ; s = s - (hours * 3600)
    mins = s // 60     ; s = s - (mins * 60)
    secs = s
    return (days, hours, mins, secs)

#-----------------------------------------------------------

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

#-----------------------------------------------------------

def write_status(doing,waitTime,target):
    log_debug('writing status file')
    statusFileName = libdir+'/status'
    statusFile = file(statusFileName,'w')
    now = datetime.datetime.now()
    statusFile.write('date='+datetime.datetime.strftime(now,'%Y-%m-%d')+'\n')
    statusFile.write('time='+datetime.datetime.strftime(now,'%H:%M:%S')+'\n')
    statusFile.write('pid='+str(os.getpid())+'\n')
    statusFile.write('wait='+str(waitTime)+'\n')
    statusFile.write('status='+doing+'\n')
    if target is not None: target=''
    statusFile.write('target='+target+'\n')
    (total, used, free) = disk_usage(topdir)
    statusFile.write('disk.mntpt='+topdir+'\n')
    statusFile.write('disk.total='+str(total)+'\n')
    statusFile.write('disk.used='+str(used)+'\n')
    statusFile.write('disk.free='+str(free)+'\n')
    statusFile.close()

#-----------------------------------------------------------

def disk_usage(path):
    """Return disk usage statistics about the given path.

    Returned value is a tuple with three attributes:
    'total', 'used' and 'free' (in bytes).
    """
    st = os.statvfs(path)
    free = st.f_bavail * st.f_frsize
    total = st.f_blocks * st.f_frsize
    used = (st.f_blocks - st.f_bfree) * st.f_frsize
    return (total, used, free)

#-----------------------------------------------------------

def buildVolumeTable():

    volumeInfo = []

    configfilename = topdir+'/config.py'
    try:
        config = imp.load_source('config', configfilename)
        log_debug("config file '"+configfilename+"' found")
        volumeInfo = config.volumeInfo
    except ImportError:
        log_debug("config file '"+configfilename+"' not found")
        pass

    # FILL IN THE 'volumeInfo' DICTIONARY

    for volume in volumeInfo:

        # set an index to refer to this entry by
        index = volume['host']+'-'+volume['name']
        volume['index'] = index

        # set some defaults
        volume['lastBackup'] = defaults.lastBackup
        volume['status'] = status.UNKNOWN

        configfiles=[]
        # (optional) config file from /backup/host/config
        configfiles.append(topdir+'/'+volume['host']+'/config')
        # (optional) config file from /backup/host/name/config
        configfiles.append(topdir+'/'+volume['host']+'/'+volume['name']+'/config')

        for configfile in configfiles:
            # read the config files if they exist
            if os.path.isfile(configfile):
                log_info("reading config file '"+configfile+"'")
                config = ConfigObj(configfile)
                # if these options are set in the config file, use them
                for key in customize:
                    if key in config:
                        log_info(' - '+index+': '+key+'='+config[key])
                        volume[key] = config[key]
            else:
                log_debug("no config file '"+configfile+"'")

        # if these options are not defined anywhere else, assign defaults
        if 'label' not in volume: volume['label'] = defaults.label
        if 'cycleMin' not in volume: volume['cycleMin'] = defaults.cycleMin
        if 'disabled' not in volume: volume['disabled'] = False
        if 'keepCount' not in volume: volume['keepCount'] = defaults.keepCount

        # force proper formats
        if isinstance(volume['cycleMin'], basestring):
            volume['cycleMin'] = int(volume['cycleMin'])
        if isinstance(volume['keepCount'], basestring):
            volume['keepCount'] = int(volume['keepCount'])
        if isinstance(volume['disabled'], basestring):
            if volume['disabled'].lower in ('yes','y','true','1'):
                volume['disabled'] = True
            else:
                volume['disabled'] = False

    # LOOK AT RECENT BACKUPS

    # TODO - don't just read all files, start from config instead
    recentBackups = glob.glob(topdir+'/*/*/*.1')
    for recentBackup in recentBackups:
        # break the wildcard (glob) into parts
        junk1, junk2, right = recentBackup.partition(topdir)
        pathpieces = right.split('/')
        host = pathpieces[1]
        name = pathpieces[2]
        # Get the creation time of the daily.1 directory.
        # Note: ctime() does not refer to creation time on *nix systems,
        # but rather the last time the inode data changed.
        lastBackup = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(os.path.getmtime(recentBackup)))
        # find the volumeInfo line that contains key='host-name'
        try:
            idx = map(operator.itemgetter('index'), volumeInfo).index(host+'-'+name)
            log_debug('host='+host+', name='+name+', lastBackup='+lastBackup+', '+host+'-'+name+' is in slot %d'%idx)
            volumeInfo[idx]['lastBackup'] = lastBackup
        except ValueError:
            log_debug('host='+host+', name='+name+', lastBackup='+lastBackup+', '+host+'-'+name+' is not in the list of volumes')
            pass

    # GO THROUGH THE LIST IN ORDER, DETERMINE THEIR AGES AND NEXT BACKUP TIME

    now = datetime.datetime.now()
    for volume in volumeInfo:
        lastBackup = datetime.datetime.strptime(volume['lastBackup'],'%Y-%m-%d %H:%M:%S')
        ageDelta = now - lastBackup
        volume['ageMin'] = (ageDelta.seconds // 60) + (ageDelta.days * 1440)
        volume['nextBackup'] = volume['cycleMin'] - volume['ageMin']
        log_debug('index='+volume['index']+', nextBackup='+str(volume['nextBackup'])+'min')
        # force disabled backups to the bottom of the list
        if volume['disabled']: volume['nextBackup'] = maxAge

    for volume in volumeInfo:
        # If "cycleMin" has transpired since our last backup, we're "ready".
        if volume['ageMin'] > volume['cycleMin']: volume['status'] = status.READY
        else: volume['status'] = status.NOT_READY
        # No matter if "ready" or not, if disabled, don't back up.
        if volume['disabled']: volume['status'] = status.DISABLED

    sortedVolumes = sorted(volumeInfo, key=operator.itemgetter('nextBackup'))

    return sortedVolumes

#-----------------------------------------------------------

def formattedTable(volumes):
    widths = { 'index':0, 'lastBackup':0, 'ageMin':0, 'cycleMin':0 }
    for volume in volumes:
        for fld in ('index','ageMin','cycleMin'):
            widths[fld] = max(widths[fld], len(str(volume[fld])))
    #widths['lastBackup'] = len('| 2013-03-20 21:05:18 | 1368/1440  |  NEXT RUN 0d+0:01:12')
    widths['lastBackup'] = len('2013-03-20 21:05:18')

    table = []
    table.append(''
        + 'INDEX'.center(widths['index'])            + '   '
        + 'LAST BACKUP'.center(widths['lastBackup']) + '   '
        + 'AGE'.center(widths['ageMin'])             + '/'
        + 'CYCLE'.center(widths['cycleMin'])         + '   '
        + 'STATUS')

    now = datetime.datetime.now()
    for volume in volumes:
        (d,h,m,s) = sec2dhms( volume['nextBackup'] * 60 )
        switch = {
            status.UNKNOWN:   '???',
            status.DISABLED:  'DISABLED',
            status.NOT_READY: 'NEXT RUN %dd+%d:%02d' % (d,h,m),
            status.READY:     'READY',
            status.SUCCEEDED: 'SUCCEEDED',
            status.FAILED:    'FAILED',
        }
        table.append(''
            + volume['index'].ljust(widths['index'])            + '   '
            + volume['lastBackup']                              + '   '
            + str(volume['ageMin']).rjust(widths['ageMin'])     + '/'
            + str(volume['cycleMin']).ljust(widths['cycleMin']) + '   '
            + switch[volume['status']]
        )

    return table

#-----------------------------------------------------------

def tableToLogAndDisk(volumeInfo):

    # CREATE A FORMATTED TABLE

    table = formattedTable(volumeInfo)

    # DUMP THE SORTED LIST IN A TEXT FILE

    tableFileName = libdir+'/queue'
    tableFile = file(tableFileName,'w')
    tableFile.write(datetime.datetime.strftime(datetime.datetime.now(),'%Y-%m-%d %H:%M:%S')+'\n')
    tableFile.write('\n')
    for line in table:
        tableFile.write(line+'\n')
    tableFile.close()

    # SHOW THE SORTED LIST IN THE LOG

    log_info('volumes:')
    for line in table:
        log_info(line)
    log_info('')

#-----------------------------------------------------------

def do_backup(v):

    write_status('backup',0,v['index'])

    args = [
        '-al',
        '-E',
        '--delete',
        '--delete-excluded',
#       '--stats',
        '--numeric-ids',
        '--one-file-system',
#       '-v',
        '--link-dest='+topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.1',
    ]

    src = v['src']
    dest = topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.0'

    # optional - "excludes" file
    excludes = topdir+'/'+v['host']+'/'+v['name']+'/excludes'
    log_debug('testing for ['+excludes+']')
    if os.path.isfile(excludes):
        log_debug('"excludes" file found, adding argument')
        args.append('--exclude-from='+excludes)

    cmd = ['/usr/bin/rsync'] + args + [src, dest]
    log_info('running >> '+(','.join(cmd)))
    rc = shell_do(cmd)

    #   0      Success
    #   1      Syntax or usage error
    #   2      Protocol incompatibility
    #   3      Errors selecting input/output files, dirs
    #   4      Requested action not supported
    #   5      Error starting client-server protocol
    #   6      Daemon unable to append to log-file
    #   10     Error in socket I/O
    #   11     Error in file I/O
    #   12     Error in rsync protocol data stream
    #   13     Errors with program diagnostics
    #   14     Error in IPC code
    #   20     Received SIGUSR1 or SIGINT
    #   21     Some error returned by waitpid()
    #   22     Error allocating core memory buffers
    #   23     Partial transfer due to error
    #   24     Partial transfer due to vanished source files
    #   25     The --max-delete limit stopped deletions
    #   30     Timeout in data send/receive
    #   35     Timeout waiting for daemon connection
    complete = True if rc in (0, 24) else False
    log_debug('rc = %d, '%rc)

    prefix = topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.'
    if os.path.isdir(prefix+'0') == False:
        log_debug(prefix+'0 directory was not found, marking incomplete')
        complete = False

    if complete:
        log_debug('backup of '+v['host']+'/'+v['name']+' is complete')
        # "touch" the timestamp
        os.utime(prefix+'0',None)
        # rotate the numbered backups
        write_status('rotate',0,v['index'])
        if os.path.isdir(prefix+str(v['keepCount'])):
            log_debug('removing '+str(v['keepCount']))
            shutil.rmtree(prefix+str(v['keepCount']))
        rotates=[]
        for i in range(v['keepCount'],0,-1):
            if os.path.isdir(prefix+str(i-1)):
                os.rename(prefix+str(i-1),prefix+str(i))
                rotates.append(str(i-1)+'>>'+str(i))
        log_debug('rotating '+('  '.join(rotates)))
    else: # not complete
        log_debug('backup of '+v['host']+'/'+v['name']+' is complete')
        if os.path.isdir(prefix+'0'):
            log_debug('removing 0')
            shutil.rmtree(prefix+'0')

    if complete:
        v['status'] = status.SUCCEEDED
    else: # not complete
        v['status'] = status.FAILED

    log_debug('done')

    return 1 if complete else 0

#-----------------------------------------------------------

def do_single_pass():

    write_status('thinking',0,None)
    volumes = buildVolumeTable()
    tableToLogAndDisk(volumes)

    # GO THROUGH THE LIST IN ORDER, BACKING UP EACH ONE IF NEEDED

    log_info('start of single pass')
    for volume in volumes:
        if volume['ageMin'] < volume['cycleMin']: continue
        if volume['disabled']: continue
        do_backup(volume)
        tableToLogAndDisk(volumes)

    write_status('idle',sleepMin,None)
    log_info('end of single pass')

    # sleep for a little bit
    for i in range(sleepMin,1,-1):
        time.sleep(60)
        write_status('idle',i,None)
        tableToLogAndDisk(volumes)

#-----------------------------------------------------------

# START
def main():

    # FIRST -- PARSE COMMAND LINE
    usage = "usage: %prog [options]"
    parser = OptionParser(usage)
    parser.add_option("-d", "--debug", action="store_true", dest="debug")
    global options
    (options, args) = parser.parse_args()
    if len(args) != 0:
        parser.error("incorrect number of arguments")

    # SET UP SERVICES

    log_init()

    # LOOK FOR PID FILE, EXIT IF FOUND

    pidfile='/var/run/'+programName+'.pid'
    try:
        with open(pidfile) as f:
            log_info("pidfile '%s' found... better look for a running process" % pidfile)
            pid = int(f.readline())
            # Check For the existence of a unix pid, send signal 0 to it.
            try:
                os.kill(pid, 0)
            except OSError:
                log_info("pid %d not found, continuing" % pid)
            else:
                log_info("pid %d is still running, exiting" % pid)
                sys.exit()
    except IOError as e:
        pass
    file(pidfile,'w').write(str(os.getpid())+'\n')

    # SET UP SUPPORT/STATUS DIRECTORY

    mkdir_p(libdir)

    # LOOP FOREVER, WORK AND SLEEP

    while True:
        do_single_pass()

    # CLEAN UP

    log_info('cleaning up')
    os.unlink(pidfile)

#-----------------------------------------------------------

if __name__ == "__main__":
     main()


