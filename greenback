#!/usr/bin/python

import os
import datetime
import subprocess
import shlex
import glob
import operator
import sys
from optparse import OptionParser
import time
import shutil
from configobj import ConfigObj         # apt-get install python-configobj
import imp
import errno

# globals
programName = 'greenback'
topdir = '/backup'
libdir = '/var/lib/'+programName
customize = ('src', 'minAge', 'disabled', 'label', 'keepCount')
maxAge = 10000000
# defaults (globals)
defaultMinAge = 86400
defaultKeepCount = 9
defaultLabel = 'daily'
# plumbing (globals)
options = ()
g_logFD = None

#-----------------------------------------------------------

def log_init():
    # we're writing these globals
    global g_logFD
    # log file
    #  logdir = os.environ['HOME']+"/var/log"
    #  if not os.path.exists(logdir):
    #     os.makedirs(logdir)
    #  logfile = logdir+"/garage.log"
    #  logfile = programName+'.log'
    logfile = '/dev/stdout'
    g_logFD = open(logfile,'a')

#-----------------------------------------------------------

def log_debug(string):
    if options.debug: log_info(string)

#-----------------------------------------------------------

def log_info(string):
    global g_logFD
    timeStamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    g_logFD.write(timeStamp+" "+string+"\n")
    g_logFD.flush()
    ##os.fsync(g_logFD)

#-----------------------------------------------------------

def shell_capture(cmdargs):
    global g_logFD
    log_debug('shell_capture command >> '+(' '.join(cmdargs)))
    p = subprocess.Popen(cmdargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    rc = p.returncode
    log_debug("shell_capture done, rc="+('%d'%rc))
    return rc, stdout, stderr

#-----------------------------------------------------------

def shell_do(cmdargs):
    global g_logFD
    log_debug('shell_do command >> '+(' '.join(cmdargs)))
    rc = subprocess.call(cmdargs)
    #rc = subprocess.call(cmdargs, stdout=g_logFD, stderr=g_logFD)
    log_debug("shell_do rc = "+("%d"%rc))
    return rc

#-----------------------------------------------------------

def sec2dhms(s):
    days = s // 86400  ; s = s - (days * 86400)
    hours = s // 3600  ; s = s - (hours * 3600)
    mins = s // 60     ; s = s - (mins * 60)
    secs = s
    return (days, hours, mins, secs)

#-----------------------------------------------------------

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

#-----------------------------------------------------------

def write_status(doing,target=None):
    statusFileName = libdir+'/status'
    statusFile = file(statusFileName,'w')
    statusFile.write('pid='+str(os.getpid())+'\n')
    statusFile.write('status='+doing+'\n')
    if target is not None:
        statusFile.write('target='+target+'\n')
    statusFile.close()

#-----------------------------------------------------------

def do_backup(v):

    write_status('backup',v['index'])

    args = [
        '-al',
        '-E',
        '--delete',
        '--delete-excluded',
#       '--stats',
        '--numeric-ids',
        '--one-file-system',
#       '-v',
        '--link-dest='+topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.1',
    ]

    src = v['src']
    dest = topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.0'

    # optional - "excludes" file
    excludes = topdir+'/'+v['host']+'/'+v['name']+'/excludes'
    log_debug('testing for ['+excludes+']')
    if os.path.isfile(excludes):
        log_debug('"excludes" file found, adding argument')
        args.append('--exclude-from='+excludes)

    rc = shell_do(['/usr/bin/rsync'] + args + [src, dest])

    #   0      Success
    #   1      Syntax or usage error
    #   2      Protocol incompatibility
    #   3      Errors selecting input/output files, dirs
    #   4      Requested action not supported
    #   5      Error starting client-server protocol
    #   6      Daemon unable to append to log-file
    #   10     Error in socket I/O
    #   11     Error in file I/O
    #   12     Error in rsync protocol data stream
    #   13     Errors with program diagnostics
    #   14     Error in IPC code
    #   20     Received SIGUSR1 or SIGINT
    #   21     Some error returned by waitpid()
    #   22     Error allocating core memory buffers
    #   23     Partial transfer due to error
    #   24     Partial transfer due to vanished source files
    #   25     The --max-delete limit stopped deletions
    #   30     Timeout in data send/receive
    #   35     Timeout waiting for daemon connection
    complete = True if rc in (0, 24) else False
    log_debug('rc = %d, '%rc)

    prefix = topdir+'/'+v['host']+'/'+v['name']+'/'+v['label']+'.'
    if os.path.isdir(prefix+'0') == False:
        log_debug(prefix+'0 directory was not found, marking incomplete')
        complete = False

    if complete:
        log_debug('backup of '+v['host']+'/'+v['name']+' is complete')
        # "touch" the timestamp
        os.utime(prefix+'0',None)
        # rotate the numbered backups
        write_status('rotate',v['index'])
        if os.path.isdir(prefix+str(v['keepCount'])):
            log_debug('removing '+str(v['keepCount']))
            shutil.rmtree(prefix+str(v['keepCount']))
        for i in range(v['keepCount'],0,-1):
            if os.path.isdir(prefix+str(i-1)):
                log_debug('renaming '+str(i-1)+' -> '+str(i))
                os.rename(prefix+str(i-1),prefix+str(i))
    else: # not complete
        log_debug('backup of '+v['host']+'/'+v['name']+' is complete')
        if os.path.isdir(prefix+'0'):
            log_debug('removing 0')
            shutil.rmtree(prefix+'0')

    log_debug('done')

#-----------------------------------------------------------

def do_single_pass():

    volumeInfo = []

    write_status('thinking')

    configfilename = topdir+'/config.py'
    try:
        config = imp.load_source('config', configfilename)
        log_debug("config file '"+configfilename+"' found")
        volumeInfo = config.volumeInfo
    except ImportError:
        log_debug("config file '"+configfilename+"' not found")
        pass

    # FILL IN THE 'volumeInfo' DICTIONARY

    for volume in volumeInfo:

        # set an index to refer to this entry by
        index = volume['host']+'-'+volume['name']
        volume['index'] = index

        # set some defaults
        volume['lastBackup'] = '2000-01-01 00:00:00'

        configfiles=[]
        # (optional) config file from /backup/host/config
        configfiles.append(topdir+'/'+volume['host']+'/config')
        # (optional) config file from /backup/host/name/config
        configfiles.append(topdir+'/'+volume['host']+'/'+volume['name']+'/config')

        for configfile in configfiles:
            # read the config files if they exist
            if os.path.isfile(configfile):
                log_info("reading config file '"+configfile+"'")
                config = ConfigObj(configfile)
                # if these options are set in the config file, use them
                for key in customize:
                    if key in config:
                        log_info(' - '+index+': '+key+'='+config[key])
                        volume[key] = config[key]
            else:
                log_debug("no config file '"+configfile+"'")

        # if these options are not defined anywhere else, assign defaults
        if 'label' not in volume: volume['label'] = defaultLabel
        if 'minAge' not in volume: volume['minAge'] = defaultMinAge
        if 'disabled' not in volume: volume['disabled'] = False
        if 'keepCount' not in volume: volume['keepCount'] = defaultKeepCount

        # force proper formats
        if isinstance(volume['minAge'], basestring):
            volume['minAge'] = int(volume['minAge'])
        if isinstance(volume['disabled'], basestring):
            if volume['disabled'].lower in ('yes','y','true','1'):
                volume['disabled'] = True

    # LOOK AT RECENT BACKUPS

    # TODO - don't just read all files, start from config instead
    recentBackups = glob.glob(topdir+'/*/*/*.1')
    for recentBackup in recentBackups:
        # break the wildcard (glob) into parts
        junk1, junk2, right = recentBackup.partition(topdir)
        pathpieces = right.split('/')
        host = pathpieces[1]
        name = pathpieces[2]
        # Get the creation time of the daily.1 directory.
        # Note: ctime() does not refer to creation time on *nix systems,
        # but rather the last time the inode data changed.
        lastBackup = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(os.path.getmtime(recentBackup)))
        # find the volumeInfo line that contains key='host-name'
        try:
            idx = map(operator.itemgetter('index'), volumeInfo).index(host+'-'+name)
            log_debug('host='+host+', name='+name+', lastBackup='+lastBackup+', '+host+'-'+name+' is in slot %d'%idx)
            volumeInfo[idx]['lastBackup'] = lastBackup
        except ValueError:
            log_debug('host='+host+', name='+name+', lastBackup='+lastBackup+', '+host+'-'+name+' is not in the list of volumes')
            pass

    # GO THROUGH THE LIST IN ORDER, DETERMINE THEIR AGES AND NEXT BACKUP TIME

    now = datetime.datetime.now()
    for volume in volumeInfo:
        lastBackup = datetime.datetime.strptime(volume['lastBackup'],'%Y-%m-%d %H:%M:%S')
        ageDelta = now - lastBackup
        currentAge = ageDelta.seconds + (ageDelta.days * 86400)
        volume['currentAge'] = currentAge
        nextBackup = volume['minAge'] - volume['currentAge']
        if volume['disabled']: nextBackup = maxAge
        volume['nextBackup'] = nextBackup

    sortedVolumes = sorted(volumeInfo, key=operator.itemgetter('nextBackup'))

    # SHOW THE SORTED LIST IN THE LOG

    maxIdxWidth = 0
    for volume in volumeInfo:
        maxIdxWidth = max(maxIdxWidth,len(volume['index']))

    log_info('volumes:')
    now = datetime.datetime.now()
    for volume in sortedVolumes:
        (d,h,m,s) = sec2dhms( volume['nextBackup'] )
        status='READY'
        if volume['currentAge'] < volume['minAge']:
            status = 'NEXT RUN %dd+%d:%02d:%02d' % (d,h,m,s)
        if volume['disabled']: status='DISABLED'
        log_info('   '+volume['index']+(' '*(maxIdxWidth-len(volume['index'])))
             +' -> '+volume['lastBackup']
             +' = '+('%d'%volume['currentAge'])+'/'+('%d'%volume['minAge'])
             +'   '+status)
    log_info('')

    # GO THROUGH THE LIST IN ORDER, BACKING UP EACH ONE IF NEEDED

    log_info('start of single pass')
    for volume in sortedVolumes:
        if volume['currentAge'] < volume['minAge']: continue
        if volume['disabled']: continue
        do_backup(volume)
    write_status('idle')
    log_info('end of single pass')

#-----------------------------------------------------------

# START
def main():

    # FIRST -- PARSE COMMAND LINE
    usage = "usage: %prog [options]"
    parser = OptionParser(usage)
    parser.add_option("-d", "--debug", action="store_true", dest="debug")
    global options
    (options, args) = parser.parse_args()
    if len(args) != 0:
        parser.error("incorrect number of arguments")

    # SET UP SERVICES

    log_init()

    # LOOK FOR PID FILE, EXIT IF FOUND

    pidfile='/var/run/'+programName+'.pid'
    try:
        with open(pidfile) as f:
            log_info("pidfile '%s' found... better look for a running process" % pidfile)
            pid = int(f.readline())
            # Check For the existence of a unix pid, send signal 0 to it.
            try:
                os.kill(pid, 0)
            except OSError:
                log_info("pid %d not found, continuing" % pid)
            else:
                log_info("pid %d is still running, exiting" % pid)
                sys.exit()
    except IOError as e:
        pass
    file(pidfile,'w').write(str(os.getpid())+'\n')

    # SET UP SUPPORT/STATUS DIRECTORY

    mkdir_p(libdir)

    # LOOP FOREVER, WORK AND SLEEP

    while True:
        do_single_pass()
        time.sleep(10*60)

    # CLEAN UP

    log_info('cleaning up')
    os.unlink(pidfile)

#-----------------------------------------------------------

if __name__ == "__main__":
     main()


